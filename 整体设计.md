## å°è½¦å·¥ä½œæµç¨‹

- ### ç³»ç»Ÿå·¥ä½œæµç¨‹è¯¦ç»†è®¾è®¡

#### 1. å¼€æœºåˆå§‹åŒ–æµç¨‹

```c
void System_Init(void) {
  PWM_Init();
  AX_PS2_Init();
  AX_DELAY_Init();
  AX_UART1_Init(115200);
  DWT_Init();
  Motion_Init(&motion);
  Gimbal_Init(&gimbal, &htim2);        // ä½¿ç”¨TIM2æ§åˆ¶äº‘å°èˆµæœº
  WaterBullet_Init(&water_bullet);
  Claw_Init(&claw, &htim2);
   //å½’ä¸­æœªå†™

}
void PWM_Init() {
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
  HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
}
```




#### 2. ä¸»å¾ªç¯è¯¦ç»†è®¾è®¡

```c
// ä¸»å¾ªç¯ä»»åŠ¡è°ƒåº¦
while (1) {
        AX_PS2_ScanKey(&joystick);

        if (joystick.mode == 0x41 || joystick.mode == 0x73 || joystick.mode == 0x79) {
            // è¿åŠ¨æ§åˆ¶
            Motion_ControlWithPS2(&motion,
                                  joystick.LJoy_UD,
                                  joystick.LJoy_LR,
                                  joystick.btn1,
                                  joystick.btn2);

            // äº‘å°æ§åˆ¶
            Gimbal_ControlWithPS2(&gimbal,
                                  joystick.RJoy_UD,
                                  joystick.RJoy_LR,
                                  joystick.btn1,
                                  joystick.btn2);

            // æ°´å¼¹å‘å°„æ§åˆ¶ - â–³æŒ‰é’®ï¼ŒæŒ‰ä½å‘å°„
            WaterBullet_ControlWithPS2(&water_bullet, joystick.btn2);

            // æŠ“å–æ§åˆ¶ - â—‹æŒ‰é’®åˆ‡æ¢æŠ“å–ï¼ŒL2/R2æ§åˆ¶å‡é™
            Claw_ControlWithPS2(&claw, joystick.btn2);
        } else {
            // PS2æ–­å¼€ä¿æŠ¤
            Motion_Stop(&motion);
            WaterBullet_ControlWithPS2(&water_bullet, 0); // å‘é€0ç¡®ä¿åœæ­¢å‘å°„
            Claw_Lift_Stop(&claw); // åœæ­¢æŠ“å–æœºæ„
        }

        // æ›´æ–°æ‰€æœ‰ç³»ç»Ÿ
        Gimbal_Update(&gimbal);
        Claw_Update(&claw);

        HAL_Delay(20);

        /* USER CODE END WHILE */

        /* USER CODE BEGIN 3 */
    }
```


- ### è¯¦ç»†æ¥çº¿å›¾ä¾‹

#### STM32F103C8T6 æ ¸å¿ƒæ¥çº¿å›¾

| å¼•è„š | åŠŸèƒ½     | è¿æ¥è®¾å¤‡           |
| :--- | :------- | :----------------- |
| PA8  | PWM      | å·¦å‰ç”µæœº PWM (ENA) |
| PB12 | æ•°å­—è¾“å‡º | å·¦å‰ç”µæœº IN1       |
| PB13 | æ•°å­—è¾“å‡º | å·¦å‰ç”µæœº IN2       |
| PA9  | PWM      | å³å‰ç”µæœº PWM (ENB) |
| PB14 | æ•°å­—è¾“å‡º | å³å‰ç”µæœº IN3       |
| PB15 | æ•°å­—è¾“å‡º | å³å‰ç”µæœº IN4       |
| PA10 | PWM      | å·¦åç”µæœº PWM (ENA) |
| PB0  | æ•°å­—è¾“å‡º | å·¦åç”µæœº IN1       |
| PB1  | æ•°å­—è¾“å‡º | å·¦åç”µæœº IN2       |
| PB3  | PWM      | å³åç”µæœº PWM (ENB) |
| PB2  | æ•°å­—è¾“å‡º | å³åç”µæœº IN3       |
| PA12 | æ•°å­—è¾“å‡º | å³åç”µæœº IN4       |
| PA0  | PWM      | äº‘å°ä¿¯ä»°èˆµæœº       |
| PA1  | PWM      | äº‘å°æ°´å¹³èˆµæœº       |
| PB5  | æ•°å­—è¾“å‡º | æ°´å¼¹å‘å°„ç”µæœºæ§åˆ¶   |
| PB10 | PWM      | æ”¶é›†æœºæ„-å‡é™èˆµæœº  |
| PB11 | PWM      | æ”¶é›†æœºæ„-å¼ åˆèˆµæœº  |
| PC13 | æ•°å­—è¾“å…¥ | ç´§æ€¥åœæ­¢æŒ‰é’®       |
| PB6  | UART_TX  | è°ƒè¯•ä¸²å£           |
| PB7  | UART_RX  | è°ƒè¯•ä¸²å£           |
| PA4  | æ•°æ®è¾“å…¥ | æ‰‹æŸ„è¿æ¥           |
| PA5  | å‘½ä»¤è¾“å‡º | æ‰‹æŸ„è¿æ¥           |
| PA6  | DI       | æ‰‹æŸ„è¿æ¥           |
| PA7  | sck      | æ‰‹æŸ„è¿æ¥           |

| ç”µæºè®¾å¤‡       | ç”µå‹ | è¿æ¥è®¾å¤‡     |
| -------------- | ---- | ------------ |
| 12V é”‚ç”µæ±      | 12V  | ç”µæœºé©±åŠ¨æ¨¡å— |
|                |      | æ°´å¼¹æ³¢ç®±     |
| DC-DCé™å‹æ¨¡å—1 | 5V   | æ‰€æœ‰èˆµæœº     |
| DC-DCé™å‹æ¨¡å—2 | 3.3V | STM32æ ¸å¿ƒæ¿  |
|                |      |              |
#### ç”µæœºé©±åŠ¨æ¥çº¿è¯¦æƒ…

```
/* 
L298N/TB6612ç”µæœºé©±åŠ¨è¿æ¥è¯´æ˜ï¼š

å·¦å‰ç”µæœºï¼š
- IN1 -> PB12 (æ–¹å‘1)
- IN2 -> PB13 (æ–¹å‘2)
- ENA -> PA8  (PWMé€Ÿåº¦)

å³å‰ç”µæœºï¼š
- IN3 -> PB14
- IN4 -> PB15  
- ENB -> PA9

å·¦åç”µæœºï¼š
- IN1 -> PB0
- IN2 -> PB1
- ENA -> PA10

å³åç”µæœºï¼š
- IN3 -> PB2
- IN4 -> PA12
- ENB -> PB3

æ³¨æ„ï¼šç”µæœºé©±åŠ¨æ¨¡å—éœ€è¦12Vä¾›ç”µï¼Œè¯·è¿æ¥é”‚ç”µæ± æ­£æ
*/
```

#### èˆµæœºç³»ç»Ÿæ¥çº¿è¯¦æƒ…

```
/*
èˆµæœºè¿æ¥è¯´æ˜ï¼š

äº‘å°ç³»ç»Ÿï¼š
1. ä¿¯ä»°èˆµæœº (ä¸Šä¸‹) -> PA0 (TIM2_CH1)
2. åèˆªèˆµæœº (å·¦å³) -> PA1 (TIM2_CH2)

æœºæ¢°è‡‚ç³»ç»Ÿï¼š
3. å‡é™èˆµæœº (MG996R) -> PB10 (TIM2_CH3)
   - æ£•è‰²çº¿ -> GND
   - çº¢è‰²çº¿ -> 5V
   - æ©™è‰²çº¿ -> ä¿¡å·çº¿
4. å¤¹çˆªèˆµæœº (SG90) -> PB11 (TIM2_CH4)

æ³¨æ„ï¼šèˆµæœºéœ€è¦5Vä¾›ç”µï¼Œè¯·ç¡®ä¿DC-DCé™å‹æ¨¡å—è¾“å‡ºè¶³å¤Ÿ
*/
```



### PS2æ‰‹æŸ„æ¥çº¿

```
/*
PS2æ‰‹æŸ„è¿æ¥è¯´æ˜ï¼š

æ‰‹æŸ„æ¥çº¿ï¼š
- PS2_DAT -> PA4 (MISO)
- PS2_CMD -> PA5 (MOSI)
- PS2_SEL -> PA6 (CS)
- PS2_CLK -> PA7 (SCK)

æ‰‹æŸ„æ¥å£å®šä¹‰ï¼š
1. DAT (MISO) -> ä¸»æœºæ¥æ”¶æ•°æ®
2. CMD (MOSI) -> ä¸»æœºå‘é€å‘½ä»¤  
3. SEL (CS)   -> ç‰‡é€‰ä¿¡å·
4. CLK (SCK)  -> æ—¶é’Ÿä¿¡å·
5. VCC        -> 3.3V
6. GND        -> GND
7. ACK        -> å¯é€‰ï¼Œæœªè¿æ¥

æ³¨æ„ï¼šä½¿ç”¨SPIé€šä¿¡ï¼Œç¡®ä¿STM32é…ç½®æ­£ç¡®
*/
```

### æ°´å¼¹å‘å°„ç³»ç»Ÿæ¥çº¿


```
/*
æ°´å¼¹å‘å°„ç³»ç»Ÿï¼š

æ°´å¼¹æ³¢ç®±ç”µæœºï¼š
- æ§åˆ¶çº¿ -> PB5
- ç”µæºæ­£ -> 12Vé”‚ç”µæ± 
- ç”µæºè´Ÿ -> GND

æ§åˆ¶é€»è¾‘ï¼š
PB5è¾“å‡ºé«˜ç”µå¹³ -> ç”µæœºè½¬åŠ¨
PB5è¾“å‡ºä½ç”µå¹³ -> ç”µæœºåœæ­¢

æ³¨æ„ï¼šå»ºè®®æ·»åŠ ç»§ç”µå™¨æˆ–MOSFETæ¨¡å—æ§åˆ¶å¤§ç”µæµ
*/

```

- ### å…³é”®ä»£ç å®ç°ç»†èŠ‚

#### ä¸»å‡½æ•°ç»“æ„

```c
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"
#include "motion.h"
#include "gimbal.h"
#include "water_bullet.h"
#include "claw.h"
#include "ps2.h"

/* Private variables ---------------------------------------------------------*/
Motion_TypeDef motion;
Gimbal_TypeDef gimbal;
WaterBullet_TypeDef water_bullet;
Claw_TypeDef claw;
PS2_Data_t joystick;

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
void System_Init(void);

int main(void) {
    /* MCUé…ç½® */
    HAL_Init();
    SystemClock_Config();
    
    /* å¤–è®¾åˆå§‹åŒ– */
    MX_GPIO_Init();
    MX_TIM1_Init();    // ç”µæœºPWM
    MX_TIM2_Init();    // èˆµæœºPWM
    MX_USART1_UART_Init();
    MX_SPI1_Init();    // PS2æ‰‹æŸ„SPI
    
    /* ç³»ç»Ÿåˆå§‹åŒ– */
    System_Init();
    HAL_Delay(1000);
    
    /* ä¸»å¾ªç¯ */
    while (1) {
        // PS2æ‰‹æŸ„æ‰«æ
        if(AX_PS2_ScanKey(&joystick) == 0) {
            // æ£€æŸ¥æ‰‹æŸ„è¿æ¥çŠ¶æ€
            if(joystick.mode == 0x41 || joystick.mode == 0x73 || joystick.mode == 0x79) {
                // è¿åŠ¨æ§åˆ¶
                Motion_ControlWithPS2(&motion,
                                      joystick.LJoy_UD,
                                      joystick.LJoy_LR,
                                      joystick.btn1,
                                      joystick.btn2);
                
                // äº‘å°æ§åˆ¶
                Gimbal_ControlWithPS2(&gimbal,
                                      joystick.RJoy_UD,
                                      joystick.RJoy_LR,
                                      joystick.btn1,
                                      joystick.btn2);
                
                // æ°´å¼¹å‘å°„æ§åˆ¶
                WaterBullet_ControlWithPS2(&water_bullet, joystick.btn2);
                
                // æŠ“å–æ§åˆ¶
                Claw_ControlWithPS2(&claw, joystick.btn2);
            } else {
                // PS2æ–­å¼€ä¿æŠ¤
                Motion_Stop(&motion);
                WaterBullet_ControlWithPS2(&water_bullet, 0);
                Claw_Lift_Stop(&claw);
            }
        }
        
        // ç³»ç»Ÿæ›´æ–°
        Gimbal_Update(&gimbal);
        Claw_Update(&claw);
        
        // çŠ¶æ€æŒ‡ç¤ºç¯ï¼ˆå¯é€‰ï¼‰
        static uint32_t led_tick = 0;
        if(HAL_GetTick() - led_tick > 500) {
            HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_3); // LEDé—ªçƒ
            led_tick = HAL_GetTick();
        }
        
        HAL_Delay(20); // 50Hzæ§åˆ¶é¢‘ç‡
    }
}

// ç³»ç»Ÿåˆå§‹åŒ–å‡½æ•°
void System_Init(void) {
    // åˆå§‹åŒ–æ‰€æœ‰å­ç³»ç»Ÿ
    Motion_Init(&motion);
    Gimbal_Init(&gimbal, &htim2);
    WaterBullet_Init(&water_bullet);
    Claw_Init(&claw, &htim2);
    
    // PS2æ‰‹æŸ„åˆå§‹åŒ–
    AX_PS2_Init();
    
    // å½’ä¸­æ“ä½œ
    Gimbal_SetAngle(&gimbal, 90, 90);
    Claw_Grip_Open(&claw);
    Claw_Lift_Stop(&claw);
    
    // åˆå§‹åŒ–çŠ¶æ€LED
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
}

// ç³»ç»Ÿæ—¶é’Ÿé…ç½®
void SystemClock_Config(void) {
    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
    
    // é…ç½®HSIä¸ºç³»ç»Ÿæ—¶é’Ÿ
    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
    RCC_OscInitStruct.HSIState = RCC_HSI_ON;
    RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
    HAL_RCC_OscConfig(&RCC_OscInitStruct);
    
    // é…ç½®ç³»ç»Ÿæ—¶é’Ÿ
    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                                |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
}
```

### å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶

```c
// ç³»ç»ŸçŠ¶æ€ç›‘æ§
typedef struct {
    uint8_t system_ok;
    uint8_t ps2_connected;
    uint8_t motor_status[4];
    uint8_t servo_status[4];
    uint32_t error_code;
} System_Status_t;

// é”™è¯¯ä»£ç å®šä¹‰
#define ERROR_NONE          0x00000000
#define ERROR_PS2_TIMEOUT   0x00000001
#define ERROR_MOTOR_FAULT   0x00000002
#define ERROR_SERVO_FAULT   0x00000004
#define ERROR_OVER_CURRENT  0x00000008
#define ERROR_BATTERY_LOW   0x00000010

// ç³»ç»Ÿç›‘æ§ä»»åŠ¡
void System_Monitor_Task(void) {
    static uint32_t last_ps2_time = 0;
    static uint8_t error_count = 0;
    
    // æ£€æŸ¥PS2è¿æ¥
    if(HAL_GetTick() - last_ps2_time > 1000) {
        // 1ç§’å†…æ²¡æœ‰PS2æ•°æ®
        error_count++;
        if(error_count > 3) {
            // è§¦å‘é”™è¯¯å¤„ç†
            Error_Handler_Timeout();
        }
    } else {
        error_count = 0;
    }
    
    // æ£€æŸ¥ç”µæ± ç”µå‹ï¼ˆå¦‚æœè¿æ¥äº†ADCï¼‰
    Check_Battery_Voltage();
    
    // æ£€æŸ¥ç”µæœºç”µæµï¼ˆå¯é€‰ï¼‰
    Check_Motor_Current();
}

// ç”µæ± ç”µå‹æ£€æµ‹
void Check_Battery_Voltage(void) {
    #define BATTERY_MIN_VOLTAGE 10.0f  // 12Vç”µæ± æœ€ä½ç”µå‹
    
    float voltage = ADC_GetBatteryVoltage();
    if(voltage < BATTERY_MIN_VOLTAGE) {
        // ä½ç”µé‡è­¦å‘Š
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_3); // å¿«é€Ÿé—ªçƒ
        // é™åˆ¶ç”µæœºåŠŸç‡
        Motion_SetMaxSpeed(128); // é™ä½æœ€å¤§é€Ÿåº¦
    }
}
```

### 



## ğŸ¯ æ¯”èµ›ç­–ç•¥

### ç§»åŠ¨ç­–ç•¥

- **æ…¢é€Ÿç¨³å®š**ï¼šä¸å¼€ç¯æ§åˆ¶ä¸‹ï¼Œå¿«é€Ÿç§»åŠ¨å®¹æ˜“å¤±æ§
- **åˆ†æ®µç§»åŠ¨**ï¼šåˆ†å°æ®µç§»åŠ¨ï¼Œæ¯æ®µç»“æŸåå¾®è°ƒä½ç½®
- **æ“ä½œæ‰‹ç»éªŒ**ï¼šé è§†è§‰åˆ¤æ–­è·ç¦»å’Œä½ç½®

### å°„å‡»ç­–ç•¥

- **è¿‘è·ç¦»å°„å‡»**ï¼šåœ¨è¾ƒè¿‘è·ç¦»å°„å‡»ï¼Œæé«˜å‘½ä¸­ç‡
- **è¦†ç›–å°„å‡»**ï¼šå¯¹ä¸€ä¸ªåŒºåŸŸè¿›è¡Œè¿ç»­å°„å‡»
- **æ“ä½œæ‰‹æ„Ÿè§‰**ï¼šé ç»éªŒä¼°è®¡å¼¹é“

### æ”¶é›†ç­–ç•¥

- **ç²¾ç¡®åˆ°ä½**ï¼šæ…¢æ…¢ç§»åŠ¨åˆ°æ¯å­æ­£å‰æ–¹
- **åå¤å°è¯•**ï¼šä¸€æ¬¡æ²¡æŠ“åˆ°å°±è°ƒæ•´ä½ç½®å†è¯•
- **å®‰å…¨ç¬¬ä¸€**ï¼šé¿å…æœºæ¢°è‡‚ç¢°æ’æŸå

## 1. ç§»åŠ¨å’Œè½¬å‘

### ç¡¬ä»¶é…ç½®

- **é©±åŠ¨ç³»ç»Ÿ**ï¼š4ä¸ªTTé©¬è¾¾ï¼Œå·®é€Ÿè½¬å‘
- **æ§åˆ¶æ ¸å¿ƒ**ï¼šSTM32F103C8T6 + ç”µæœºé©±åŠ¨æ¨¡å—
- **ä¾›ç”µç³»ç»Ÿ**ï¼š12Vé”‚ç”µæ± ï¼Œç¡®ä¿åŠ¨åŠ›å……è¶³

### æ§åˆ¶å®ç°

```c
// ç”µæœºå¼•è„šå®šä¹‰
// PWMå¼•è„š - TIM1
#define MOTOR_LF_PWM_PIN GPIO_PIN_8    // PA8 - TIM1_CH1
#define MOTOR_RF_PWM_PIN GPIO_PIN_9    // PA9 - TIM1_CH2
#define MOTOR_LB_PWM_PIN GPIO_PIN_10   // PA10 - TIM1_CH3
#define MOTOR_RB_PWM_PIN GPIO_PIN_11   // PA11 - TIM1_CH4

// æ–¹å‘å¼•è„š
#define MOTOR_LF_DIR_PIN GPIO_PIN_12   // PB12
#define MOTOR_RF_DIR_PIN GPIO_PIN_13   // PB13
#define MOTOR_LB_DIR_PIN GPIO_PIN_14   // PB14
#define MOTOR_RB_DIR_PIN GPIO_PIN_15   // PB15

// ç”µæœºç»“æ„ä½“
typedef struct {
    GPIO_TypeDef* dir_port;
    uint16_t dir_pin;
    TIM_HandleTypeDef* pwm_tim;
    uint32_t pwm_channel;
    int16_t speed;  // -255 to 255
} Motor_TypeDef;

// è¿åŠ¨æ§åˆ¶ç»“æ„ä½“
typedef struct {
    Motor_TypeDef lf_motor;  // å·¦å‰ç”µæœº
    Motor_TypeDef rf_motor;  // å³å‰ç”µæœº
    Motor_TypeDef lb_motor;  // å·¦åç”µæœº
    Motor_TypeDef rb_motor;  // å³åç”µæœº
} Motion_TypeDef;

// è¿åŠ¨æ¨¡å¼æšä¸¾
typedef enum {
    MODE_STOP = 0,
    MODE_FORWARD,
    MODE_BACKWARD,
    MODE_LEFT,
    MODE_RIGHT,
    MODE_FORWARD_LEFT,
    MODE_FORWARD_RIGHT,
    MODE_BACKWARD_LEFT,
    MODE_BACKWARD_RIGHT,
    MODE_SPIN_LEFT,
    MODE_SPIN_RIGHT
} Motion_Mode;
// å®šä¹‰
#define DEAD_ZONE 30
#define PWM_MAX 255
#define MAX(a, b) ((a) > (b) ? (a) : (b))

// ç”µæœºåˆå§‹åŒ–
void Motion_Init(Motion_TypeDef* motion)
{
    // åˆå§‹åŒ–å·¦å‰ç”µæœº
    motion->lf_motor.dir_port = GPIOB;
    motion->lf_motor.dir_pin = MOTOR_LF_DIR_PIN;
    motion->lf_motor.pwm_tim = &htim1;
    motion->lf_motor.pwm_channel = TIM_CHANNEL_1;
    motion->lf_motor.speed = 0;

    // åˆå§‹åŒ–å³å‰ç”µæœº
    motion->rf_motor.dir_port = GPIOB;
    motion->rf_motor.dir_pin = MOTOR_RF_DIR_PIN;
    motion->rf_motor.pwm_tim = &htim1;
    motion->rf_motor.pwm_channel = TIM_CHANNEL_2;
    motion->rf_motor.speed = 0;

    // åˆå§‹åŒ–å·¦åç”µæœº
    motion->lb_motor.dir_port = GPIOB;
    motion->lb_motor.dir_pin = MOTOR_LB_DIR_PIN;
    motion->lb_motor.pwm_tim = &htim1;
    motion->lb_motor.pwm_channel = TIM_CHANNEL_3;
    motion->lb_motor.speed = 0;

    // åˆå§‹åŒ–å³åç”µæœº
    motion->rb_motor.dir_port = GPIOB;
    motion->rb_motor.dir_pin = MOTOR_RB_DIR_PIN;
    motion->rb_motor.pwm_tim = &htim1;
    motion->rb_motor.pwm_channel = TIM_CHANNEL_4;
    motion->rb_motor.speed = 0;

    // å¯åŠ¨æ‰€æœ‰PWMé€šé“
    Motion_Enable(motion, 1);

    // åˆå§‹åŒ–ä¸ºåœæ­¢çŠ¶æ€
    Motion_Stop(motion);
}

// ç”µæœºä½¿èƒ½æ§åˆ¶
void Motion_Enable(Motion_TypeDef* motion, uint8_t enable)
{
    if(enable) {
        HAL_TIM_PWM_Start(motion->lf_motor.pwm_tim, motion->lf_motor.pwm_channel);
        HAL_TIM_PWM_Start(motion->rf_motor.pwm_tim, motion->rf_motor.pwm_channel);
        HAL_TIM_PWM_Start(motion->lb_motor.pwm_tim, motion->lb_motor.pwm_channel);
        HAL_TIM_PWM_Start(motion->rb_motor.pwm_tim, motion->rb_motor.pwm_channel);
    } else {
        Motion_Stop(motion);
        HAL_TIM_PWM_Stop(motion->lf_motor.pwm_tim, motion->lf_motor.pwm_channel);
        HAL_TIM_PWM_Stop(motion->rf_motor.pwm_tim, motion->rf_motor.pwm_channel);
        HAL_TIM_PWM_Stop(motion->lb_motor.pwm_tim, motion->lb_motor.pwm_channel);
        HAL_TIM_PWM_Stop(motion->rb_motor.pwm_tim, motion->rb_motor.pwm_channel);
    }
}

// è®¾ç½®å•ä¸ªç”µæœºçš„é€Ÿåº¦å’Œæ–¹å‘
static void Motor_SetSpeed(Motor_TypeDef* motor, int16_t speed)
{
    // é™åˆ¶é€Ÿåº¦èŒƒå›´
    if(speed > PWM_MAX) speed = PWM_MAX;
    if(speed < -PWM_MAX) speed = -PWM_MAX;

    motor->speed = speed;

    if(speed >= 0) {
        // æ­£è½¬
        HAL_GPIO_WritePin(motor->dir_port, motor->dir_pin, GPIO_PIN_SET);
        __HAL_TIM_SET_COMPARE(motor->pwm_tim, motor->pwm_channel, speed);
    } else {
        // åè½¬
        HAL_GPIO_WritePin(motor->dir_port, motor->dir_pin, GPIO_PIN_RESET);
        __HAL_TIM_SET_COMPARE(motor->pwm_tim, motor->pwm_channel, -speed);
    }
}

// è®¾ç½®æ‰€æœ‰ç”µæœºé€Ÿåº¦
void Motion_SetSpeed(Motion_TypeDef* motion, int16_t lf_speed, int16_t rf_speed, int16_t lb_speed, int16_t rb_speed)
{
    Motor_SetSpeed(&motion->lf_motor, lf_speed);
    Motor_SetSpeed(&motion->rf_motor, rf_speed);
    Motor_SetSpeed(&motion->lb_motor, lb_speed);
    Motor_SetSpeed(&motion->rb_motor, rb_speed);
}

// åœæ­¢æ‰€æœ‰ç”µæœº
void Motion_Stop(Motion_TypeDef* motion)
{
    Motion_SetSpeed(motion, 0, 0, 0, 0);
}

// æ ¹æ®è¿åŠ¨æ¨¡å¼ç§»åŠ¨
void Motion_Move(Motion_TypeDef* motion, Motion_Mode mode, uint8_t speed)
{
    switch(mode) {
        case MODE_STOP:
            Motion_SetSpeed(motion, 0, 0, 0, 0);
            break;

        case MODE_FORWARD:
            Motion_SetSpeed(motion, speed, speed, speed, speed);
            break;

        case MODE_BACKWARD:
            Motion_SetSpeed(motion, -speed, -speed, -speed, -speed);
            break;

        case MODE_LEFT:
            // å·¦è½¬ - å·¦ä¾§åé€€ï¼Œå³ä¾§å‰è¿›
            Motion_SetSpeed(motion, -speed, speed, -speed, speed);
            break;

        case MODE_RIGHT:
            // å³è½¬ - å·¦ä¾§å‰è¿›ï¼Œå³ä¾§åé€€
            Motion_SetSpeed(motion, speed, -speed, speed, -speed);
            break;

        case MODE_FORWARD_LEFT:
            // å·¦å‰æ–¹ç§»åŠ¨
            Motion_SetSpeed(motion, 0, speed, speed, 0);
            break;

        case MODE_FORWARD_RIGHT:
            // å³å‰æ–¹ç§»åŠ¨
            Motion_SetSpeed(motion, speed, 0, 0, speed);
            break;

        case MODE_BACKWARD_LEFT:
            // å·¦åæ–¹ç§»åŠ¨
            Motion_SetSpeed(motion, -speed, 0, 0, -speed);
            break;

        case MODE_BACKWARD_RIGHT:
            // å³åæ–¹ç§»åŠ¨
            Motion_SetSpeed(motion, 0, -speed, -speed, 0);
            break;

        case MODE_SPIN_LEFT:
            // åŸåœ°å·¦è½¬
            Motion_SetSpeed(motion, -speed, speed, -speed, speed);
            break;

        case MODE_SPIN_RIGHT:
            // åŸåœ°å³è½¬
            Motion_SetSpeed(motion, speed, -speed, speed, -speed);
            break;
    }
}

// åŸºäºPS2æ‰‹æŸ„æ§åˆ¶
void Motion_ControlWithPS2(Motion_TypeDef* motion, uint8_t LJoy_UD, uint8_t LJoy_LR, uint8_t btn1, uint8_t btn2)
{
    // æ›´æ¸…æ™°çš„æ‘‡æ†æ–¹å‘å¤„ç†
    int16_t ud_value = 128 - (int16_t)LJoy_UD;  // ä¸Š=æ­£ï¼Œä¸‹=è´Ÿ
    int16_t lr_value = (int16_t)LJoy_LR - 128;  // å³=æ­£ï¼Œå·¦=è´Ÿ

    // åº”ç”¨æ­»åŒº
    if(abs(ud_value) < DEAD_ZONE) ud_value = 0;
    if(abs(lr_value) < DEAD_ZONE) lr_value = 0;

    // æ˜ å°„åˆ°é€Ÿåº¦å€¼
    int16_t forward_speed = (ud_value * PWM_MAX) / 128;
    int16_t turn_speed = (lr_value * PWM_MAX) / 128;

    // åˆå§‹åŒ–ç”µæœºé€Ÿåº¦
    int16_t left_speed = forward_speed;
    int16_t right_speed = forward_speed;

    // æ£€æŸ¥ç‰¹æ®ŠæŒ‰é’®æ§åˆ¶
    uint8_t special_mode = 0;

    // åœ¨Motion_ControlWithPS2å‡½æ•°ä¸­ä¿æŒL1/R1è½¬å‘æ§åˆ¶
    if(btn2 & 0x01) { // L1 - åŸåœ°å·¦è½¬
        Motion_Move(motion, MODE_SPIN_LEFT, 150);
        special_mode = 1;
    } else if(btn2 & 0x02) { // R1 - åŸåœ°å³è½¬
        Motion_Move(motion, MODE_SPIN_RIGHT, 150);
        special_mode = 1;
    }

    // åªæœ‰æ²¡æœ‰ç‰¹æ®Šæ¨¡å¼æ—¶æ‰ä½¿ç”¨æ‘‡æ†æ§åˆ¶
    if(!special_mode) {
        if(ud_value != 0 || lr_value != 0) {
            // åº”ç”¨è½¬å‘
            if(turn_speed != 0) {
                left_speed = forward_speed - turn_speed;
                right_speed = forward_speed + turn_speed;

                // ä¿æŒæœ€å¤§é€Ÿåº¦ä¸è¶…è¿‡é™åˆ¶
                int16_t max_abs = MAX(abs(left_speed), abs(right_speed));
                if(max_abs > PWM_MAX) {
                    float scale = (float)PWM_MAX / max_abs;
                    left_speed = (int16_t)(left_speed * scale);
                    right_speed = (int16_t)(right_speed * scale);
                }
            }

            // æ­£å¸¸æ‘‡æ†æ§åˆ¶
            Motion_SetSpeed(motion, left_speed, right_speed, left_speed, right_speed);
        } else {
            // æ‘‡æ†å›ä¸­æ—¶åœæ­¢
            Motion_Stop(motion);
        }
    }
}
```



### é«˜çº§åŠŸèƒ½

- **é€Ÿåº¦å¹³æ»‘**ï¼šä½¿ç”¨åŠ é€Ÿåº¦é™åˆ¶ï¼Œé¿å…æ€¥åœæ€¥å¯
- **æ­»åŒºå¤„ç†**ï¼šæ‘‡æ†ä¸­å¿ƒæ­»åŒºï¼Œé˜²æ­¢å¾®å°æ¼‚ç§»
- **å¡åº¦è¡¥å¿**ï¼šé£å¡æ—¶è‡ªåŠ¨å¢åŠ åŠ¨åŠ›è¾“å‡º
- **è¾¹ç•Œæ£€æµ‹**ï¼šæ¥è¿‘åœºåœ°è¾¹ç•Œæ—¶æä¾›è§¦è§‰åé¦ˆ

## 2. æ°´æªç§»åŠ¨

### ç¡¬ä»¶é…ç½®

- **äº‘å°ç»“æ„**ï¼š2ä¸ªèˆµæœºç»„æˆäºŒè½´äº‘å°ï¼ˆä¿¯ä»°+æ°´å¹³ï¼‰
- **å‘å°„æœºæ„**ï¼šæ°´å¼¹æ³¢ç®± + èˆµæœºè§¦å‘
- **å¼¹ä»“ç³»ç»Ÿ**ï¼šæ°´å¼¹å¼¹ä»“ï¼Œå®¹é‡çº¦100å‘

### æ§åˆ¶å®ç°

```c
// äº‘å°èˆµæœºå¼•è„šå®šä¹‰
#define GIMBAL_PITCH_PIN GPIO_PIN_0    // PA0 - ä¿¯ä»°èˆµæœº (ä¸Šä¸‹)
#define GIMBAL_PITCH_PORT GPIOA
#define GIMBAL_YAW_PIN GPIO_PIN_1      // PA1 - åèˆªèˆµæœº (å·¦å³)

// æ°´å¼¹å‘å°„ç”µæœºå¼•è„š
#define WATER_BULLET_PIN GPIO_PIN_2    // PA2 - æ°´å¼¹å‘å°„ç”µæœºæ§åˆ¶
#define WATER_BULLET_PORT GPIOA

// äº‘å°è§’åº¦é™åˆ¶
#define GIMBAL_PITCH_MIN 30    // ä¿¯ä»°æœ€å°è§’åº¦
#define GIMBAL_PITCH_MAX 150   // ä¿¯ä»°æœ€å¤§è§’åº¦
#define GIMBAL_YAW_MIN 0       // åèˆªæœ€å°è§’åº¦
#define GIMBAL_YAW_MAX 180     // åèˆªæœ€å¤§è§’åº¦

// äº‘å°æ§åˆ¶ç»“æ„ä½“
typedef struct {
    uint8_t current_pitch;     // å½“å‰ä¿¯ä»°è§’åº¦
    uint8_t current_yaw;       // å½“å‰åèˆªè§’åº¦
    uint8_t target_pitch;      // ç›®æ ‡ä¿¯ä»°è§’åº¦
    uint8_t target_yaw;        // ç›®æ ‡åèˆªè§’åº¦
    TIM_HandleTypeDef* pwm_tim; // PWMå®šæ—¶å™¨
} Gimbal_TypeDef;

// æ°´å¼¹å‘å°„æ§åˆ¶
typedef struct {
    uint8_t is_shooting;       // æ˜¯å¦æ­£åœ¨å‘å°„
} WaterBullet_TypeDef;
// è§’åº¦è½¬PWMæ¯”è¾ƒå€¼
static uint32_t AngleToCompare(int angle)
{
    if (angle < 0) angle = 0;
    if (angle > 180) angle = 180;
    return (uint32_t)(500 + angle * 2000 / 180);
}

// äº‘å°åˆå§‹åŒ–
void Gimbal_Init(Gimbal_TypeDef* gimbal, TIM_HandleTypeDef* pwm_tim)
{
    gimbal->pwm_tim = pwm_tim;
    gimbal->current_pitch = 90;
    gimbal->current_yaw = 90;
    gimbal->target_pitch = 90;
    gimbal->target_yaw = 90;

    // è®¾ç½®åˆå§‹ä½ç½®
    __HAL_TIM_SET_COMPARE(gimbal->pwm_tim, TIM_CHANNEL_1, AngleToCompare(gimbal->current_pitch));
    __HAL_TIM_SET_COMPARE(gimbal->pwm_tim, TIM_CHANNEL_2, AngleToCompare(gimbal->current_yaw));
}

// è®¾ç½®äº‘å°è§’åº¦
void Gimbal_SetAngle(Gimbal_TypeDef* gimbal, uint8_t pitch, uint8_t yaw)
{
    if(pitch < GIMBAL_PITCH_MIN) pitch = GIMBAL_PITCH_MIN;
    if(pitch > GIMBAL_PITCH_MAX) pitch = GIMBAL_PITCH_MAX;
    if(yaw < GIMBAL_YAW_MIN) yaw = GIMBAL_YAW_MIN;
    if(yaw > GIMBAL_YAW_MAX) yaw = GIMBAL_YAW_MAX;

    gimbal->target_pitch = pitch;
    gimbal->target_yaw = yaw;
}

// åŸºäºPS2æ‰‹æŸ„æ§åˆ¶äº‘å°
void Gimbal_ControlWithPS2(Gimbal_TypeDef* gimbal, uint8_t RJoy_UD, uint8_t RJoy_LR, uint8_t btn1, uint8_t btn2)
{
    #define GIMBAL_DEAD_ZONE 20
    #define GIMBAL_SPEED 3

    int16_t ud_value = 128 - (int16_t)RJoy_UD;  // ä¸Š=æ­£ï¼Œä¸‹=è´Ÿ
    int16_t lr_value = (int16_t)RJoy_LR - 128;  // å³=æ­£ï¼Œå·¦=è´Ÿ

    // åº”ç”¨æ­»åŒº
    if(abs(ud_value) < GIMBAL_DEAD_ZONE) ud_value = 0;
    if(abs(lr_value) < GIMBAL_DEAD_ZONE) lr_value = 0;

    // å³æ‘‡æ†æ§åˆ¶äº‘å°
    if(ud_value != 0) {
        gimbal->target_pitch += (ud_value > 0) ? GIMBAL_SPEED : -GIMBAL_SPEED;
    }

    if(lr_value != 0) {
        gimbal->target_yaw += (lr_value > 0) ? GIMBAL_SPEED : -GIMBAL_SPEED;
    }

    // STARTæŒ‰é’® - å¤ä½äº‘å°
    if(btn1 & 0x08) {
        gimbal->target_pitch = 90;
        gimbal->target_yaw = 90;
    }
}

// æ›´æ–°äº‘å°ä½ç½®
void Gimbal_Update(Gimbal_TypeDef* gimbal)
{
    // å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
    if(abs(gimbal->current_pitch - gimbal->target_pitch) > 1) {
        if(gimbal->current_pitch < gimbal->target_pitch) {
            gimbal->current_pitch++;
        } else {
            gimbal->current_pitch--;
        }
        __HAL_TIM_SET_COMPARE(gimbal->pwm_tim, TIM_CHANNEL_1, AngleToCompare(gimbal->current_pitch));
    }

    if(abs(gimbal->current_yaw - gimbal->target_yaw) > 1) {
        if(gimbal->current_yaw < gimbal->target_yaw) {
            gimbal->current_yaw++;
        } else {
            gimbal->current_yaw--;
        }
        __HAL_TIM_SET_COMPARE(gimbal->pwm_tim, TIM_CHANNEL_2, AngleToCompare(gimbal->current_yaw));
    }
}

// æ°´å¼¹å‘å°„åˆå§‹åŒ–
void WaterBullet_Init(WaterBullet_TypeDef* shooter)
{
    shooter->is_shooting = 0;
    // åˆå§‹åŒ–GPIO - ç¡®ä¿ç”µæœºåˆå§‹çŠ¶æ€ä¸ºåœæ­¢
    HAL_GPIO_WritePin(WATER_BULLET_PORT, WATER_BULLET_PIN, GPIO_PIN_RESET);
}

// åŸºäºPS2æ§åˆ¶æ°´å¼¹å‘å°„ - ä½¿ç”¨â–³æŒ‰é’®ï¼ŒæŒ‰ä½å‘å°„ï¼Œæ¾å¼€åœæ­¢
void WaterBullet_ControlWithPS2(WaterBullet_TypeDef* shooter, uint8_t btn2)
{
    static uint8_t last_btn2 = 0;

    // â–³æŒ‰é’® (0x10) - æŒ‰ä½å‘å°„ï¼Œæ¾å¼€åœæ­¢
    if(btn2 & 0x10) {
        // æŒ‰é’®æŒ‰ä¸‹ - å¼€å§‹å‘å°„
        if(!shooter->is_shooting) {
            shooter->is_shooting = 1;
            HAL_GPIO_WritePin(WATER_BULLET_PORT, WATER_BULLET_PIN, GPIO_PIN_SET);
        }
    } else {
        // æŒ‰é’®æ¾å¼€ - åœæ­¢å‘å°„
        if(shooter->is_shooting) {
            shooter->is_shooting = 0;
            HAL_GPIO_WritePin(WATER_BULLET_PORT, WATER_BULLET_PIN, GPIO_PIN_RESET);
        }
    }

    last_btn2 = btn2;
}
```



### å°„å‡»ä¼˜åŒ–ç­–ç•¥

- **è¿å‘æ¨¡å¼**ï¼šå¿«é€Ÿè¿ç»­å°„å‡»ï¼Œæé«˜å‘½ä¸­æ¦‚ç‡
- **ç‚¹å°„æ¨¡å¼**ï¼šç²¾ç¡®ç„å‡†ï¼ŒèŠ‚çœå¼¹è¯
- **å¼¹é“è¡¥å¿**ï¼šæ ¹æ®è·ç¦»è‡ªåŠ¨è°ƒæ•´ç„å‡†é«˜åº¦
- **å†·å´ç®¡ç†**ï¼šé˜²æ­¢æ³¢ç®±è¿‡çƒ­ï¼Œè®¾ç½®å‘å°„é—´éš”

## 3. å®ç°æŠ“å–

### æœºæ¢°ç»“æ„è®¾è®¡

- **è‡‚æ¶ç»“æ„**ï¼š1è‡ªç”±åº¦æœºæ¢°è‡‚ï¼ˆå‡é™ï¼‰
- **æœ«ç«¯æ‰§è¡Œå™¨**ï¼š2æŒ‡å¤¹çˆªæ”¶é›†å™¨
- **é©±åŠ¨æ–¹å¼**ï¼š2ä¸ªèˆµæœºï¼ˆå‡é™1ä¸ª,å¤¹çˆª1ä¸ªï¼‰

### æ§åˆ¶å®ç°

```c
// æŠ“å–æœºæ„èˆµæœºå¼•è„šå®šä¹‰
#define CLAW_LIFT_PIN GPIO_PIN_10      // PB10 - å‡é™èˆµæœº (MG996R 360åº¦)
#define CLAW_LIFT_PORT GPIOB
#define CLAW_GRIP_PIN GPIO_PIN_11      // PB11 - æŠ“å–èˆµæœº (SG90 180åº¦)  
#define CLAW_GRIP_PORT GPIOB

// æŠ“å–çŠ¶æ€æšä¸¾
typedef enum {
    CLAW_STATE_OPEN = 0,       // çˆªå­å¼ å¼€
    CLAW_STATE_CLOSED          // çˆªå­é—­åˆ
} ClawState_TypeDef;

// æŠ“å–æ§åˆ¶ç»“æ„ä½“
typedef struct {
    ClawState_TypeDef grip_state;      // æŠ“å–çŠ¶æ€
    uint8_t is_lifting;                // æ˜¯å¦æ­£åœ¨å‡é™
    TIM_HandleTypeDef* pwm_tim;        // PWMå®šæ—¶å™¨
} Claw_TypeDef;
// è§’åº¦è½¬PWMæ¯”è¾ƒå€¼ (SG90 180åº¦èˆµæœº)
static uint32_t AngleToCompare_SG90(int angle)
{
    if (angle < 0) angle = 0;
    if (angle > 180) angle = 180;
    return (uint32_t)(500 + angle * 2000 / 180);
}

// MG996R 360åº¦èˆµæœºé€Ÿåº¦æ§åˆ¶
static void MG996R_SetSpeed(TIM_HandleTypeDef* tim, uint32_t channel, int8_t speed)
{
    // é€Ÿåº¦èŒƒå›´: -100 åˆ° 100
    // å¯¹åº”PWM: 5% (1ms) åˆ° 10% (2ms)
    if(speed < -100) speed = -100;
    if(speed > 100) speed = 100;
    
    // æ˜ å°„åˆ°PWMå€¼: 1000 (1ms) åˆ° 2000 (2ms)
    uint32_t pwm_value = 1500 + speed * 5;  // ä¸­ä½1500ï¼ŒÂ±500
    __HAL_TIM_SET_COMPARE(tim, channel, pwm_value);
}

// æŠ“å–æœºæ„åˆå§‹åŒ–
void Claw_Init(Claw_TypeDef* claw, TIM_HandleTypeDef* pwm_tim)
{
    claw->pwm_tim = pwm_tim;
    claw->grip_state = CLAW_STATE_OPEN;
    claw->is_lifting = 0;

    // åˆå§‹åŒ–ä½ç½®
    Claw_Grip_Open(claw);
    Claw_Lift_Stop(claw);
}

// åŸºäºPS2æ§åˆ¶æŠ“å–æœºæ„
void Claw_ControlWithPS2(Claw_TypeDef* claw, uint8_t btn2)
{
    static uint8_t last_btn2 = 0;

    // â—‹æŒ‰é’® (0x40) - åˆ‡æ¢æŠ“å–çŠ¶æ€
    if((btn2 & 0x40) && !(last_btn2 & 0x40)) {
        if(claw->grip_state == CLAW_STATE_OPEN) {
            Claw_Grip_Close(claw);
            claw->grip_state = CLAW_STATE_CLOSED;
        } else {
            Claw_Grip_Open(claw);
            claw->grip_state = CLAW_STATE_OPEN;
        }
    }

    // L2æŒ‰é’® (0x01) - å‡èµ·å¤¹å­
    if(btn2 & 0x01) {
        if(!claw->is_lifting) {
            claw->is_lifting = 1;
            Claw_Lift_Up(claw);
        }
    }
    // R2æŒ‰é’® (0x02) - é™ä¸‹å¤¹å­
    else if(btn2 & 0x02) {
        if(!claw->is_lifting) {
            claw->is_lifting = 1;
            Claw_Lift_Down(claw);
        }
    }
    // æ²¡æœ‰æŒ‰ä¸‹L2æˆ–R2æ—¶åœæ­¢å‡é™
    else {
        if(claw->is_lifting) {
            claw->is_lifting = 0;
            Claw_Lift_Stop(claw);
        }
    }

    last_btn2 = btn2;
}

// æ›´æ–°æŠ“å–æœºæ„çŠ¶æ€
void Claw_Update(Claw_TypeDef* claw)
{
    // è¿™é‡Œå¯ä»¥æ·»åŠ å…¶ä»–çŠ¶æ€æ›´æ–°é€»è¾‘
    // ç›®å‰åªéœ€è¦å®æ—¶å“åº”æŒ‰é’®ï¼Œä¸éœ€è¦é¢å¤–æ›´æ–°
}

// MG996R 360åº¦èˆµæœºæ§åˆ¶å‡½æ•°
void Claw_Lift_Up(Claw_TypeDef* claw)
{
    // æ­£è½¬ - ä¸Šå‡
    MG996R_SetSpeed(claw->pwm_tim, TIM_CHANNEL_3, 80);  // ä½¿ç”¨TIM_CHANNEL_3
}

void Claw_Lift_Down(Claw_TypeDef* claw)
{
    // åè½¬ - ä¸‹é™
    MG996R_SetSpeed(claw->pwm_tim, TIM_CHANNEL_3, -80); // ä½¿ç”¨TIM_CHANNEL_3
}

void Claw_Lift_Stop(Claw_TypeDef* claw)
{
    // åœæ­¢
    MG996R_SetSpeed(claw->pwm_tim, TIM_CHANNEL_3, 0);
}

// SG90 180åº¦èˆµæœºæ§åˆ¶å‡½æ•°
void Claw_Grip_Open(Claw_TypeDef* claw)
{
    // å¼ å¼€çˆªå­ - 0åº¦
    __HAL_TIM_SET_COMPARE(claw->pwm_tim, TIM_CHANNEL_4, AngleToCompare_SG90(0));
}

void Claw_Grip_Close(Claw_TypeDef* claw)
{
    // é—­åˆçˆªå­ - 180åº¦
    __HAL_TIM_SET_COMPARE(claw->pwm_tim, TIM_CHANNEL_4, AngleToCompare_SG90(180));
}
```



### æŠ“å–ç­–ç•¥ä¼˜åŒ–

- **ç¤ºæ•™ç¼–ç¨‹**ï¼šèµ›å‰å½•åˆ¶å…³é”®ä½ç½®ï¼Œæ¯”èµ›æ—¶ä¸€é”®è°ƒç”¨
- **è‡ªé€‚åº”æŠ“å–**ï¼šæ ¹æ®ä¼ æ„Ÿå™¨åé¦ˆè°ƒæ•´æŠ“å–åŠ›åº¦
- **é˜²æ’ä¿æŠ¤**ï¼šæœºæ¢°è‡‚è¿åŠ¨è¿‡ç¨‹ä¸­çš„ç¢°æ’æ£€æµ‹
- **ç‰©èµ„è®¡æ•°**ï¼šé€šè¿‡ä¼ æ„Ÿå™¨ç»Ÿè®¡æˆåŠŸæ”¶é›†çš„ç‰©èµ„æ•°é‡

## ç³»ç»Ÿé›†æˆä¸ä¼˜åŒ–

### çŠ¶æ€ç®¡ç†

```c
// å…¨å±€æœºå™¨äººçŠ¶æ€
```

## æŒ‰é’®æ˜ å°„

| æ§åˆ¶åŠŸèƒ½     | æŒ‰é’®/æ‘‡æ† | è¯´æ˜                             |
| :----------- | :-------- | :------------------------------- |
| **ç§»åŠ¨æ§åˆ¶** | å·¦æ‘‡æ†    | å‰åå·¦å³ç§»åŠ¨                     |
|              | L1        | åŸåœ°å·¦è½¬                         |
|              | R1        | åŸåœ°å³è½¬                         |
| **äº‘å°æ§åˆ¶** | å³æ‘‡æ†    | æ§åˆ¶äº‘å°ç„å‡†                     |
|              | START     | äº‘å°å¤ä½                         |
| **æ°´å¼¹å‘å°„** | â–³æŒ‰é’®(Y)  | å‘å°„æ°´å¼¹ï¼ˆæŒ‰ä½å‘å°„ï¼Œæ¾å¼€ä¸å‘å°„ï¼‰ |
| **æŠ“å–æ§åˆ¶** | â—‹æŒ‰é’®(C)  | æŠ“å–/é‡Šæ”¾åˆ‡æ¢                    |
|              | L2        | å‡èµ·å¤¹å­                         |
|              | R2        | é™ä¸‹å¤¹å­                         |